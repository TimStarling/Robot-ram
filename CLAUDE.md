# 基于CANOpen协议，DS402子协议的巨蟹机械臂驱动程序上位机


## 目标平台
#### 运行的平台配置如下：（Orangepi5）  
CPU配置：
Architecture:           aarch64  
  CPU op-mode(s):       32-bit, 64-bit  
  Byte Order:           Little Endian  
CPU(s):                 8  
  On-line CPU(s) list:  0-7  
Vendor ID:              ARM  
  Model name:           Cortex-A55
    Model:              0  
    Thread(s) per core: 1  
    Core(s) per socket: 4  
    Socket(s):          1  
    Stepping:           r2p0  
    CPU max MHz:        1800.  
    CPU min MHz:        408.0000  
    BogoMIPS:           48.00  
    Flags:              fp asimd evtstrm aes pmull sha1 sha2 crc32 atomics fphp asimdhp cpuid asimdrdm lrcpc dcpop asimddp  
  Model name:           Cortex-A76  

  内存配置为16G

#### 调试平台

X86 
操作系统为Win10或者Ubuntu22.04

## 编码标准
C++17  
使用Doxygen风格编写注释

## 语言标准
使用中文和UTF8编码输出

## 接口标准
对外调用库时使用C风格接口。
目标需要包装成Pybind11库，也有可能直接编译成C++库或者可执行程序，取决于需求。

## 错误输出和处理标准
输出格式如下：
[ERROR][错误发生的函数或者模块名或者类名]:错误细节

如果能抛出异常则在输出错误码之后抛出异常

## 内联需求
在对性能敏感（如线程切换和通信、延迟要求低的场合等）或者调用次数多的部分，鼓励使用内联降低调用开销

## 其余需求
读取CSV文件，以此来方便进行机械臂动作重现。
未来可能需要运动学或者示教等高级功能应用，或者日志功能记录收发的CAN帧（当前暂无本需求）

## 机械臂本身物理参数和需求
CAN总线带宽1M，总线上电机为6个（也有可能是4个或者多个，但是不会太多）一条机械臂有六个电机，
这六个电机在同一个总线上。  
总线通过一个串口转CAN口芯片，总线和上位机相连接，上位机只需要根据转换芯片的协议发送一个特殊的数据帧来代替CAN帧，芯片就可以将其转换成原生CAN帧。  
具体的协议封装格式可以在CAN_frame.hpp文件中查看。  
有可能驱动程序需要驱动多条机械臂，这些机械臂使用不同的串口，所以相应的线程和数据结构也需要额外复制一份或者多份。  
在总体设计上应该支持多线程，并且考虑到线程竞争导致的效率和安全问题。同步时间为2ms进行一次同步，即2ms进行一轮发送和接收。每一轮操作的情况不定，通常在需要进行配置或者模式切换的时候会在那个周期发送十个到几十个SDO帧，剩下的都是PDO帧。其余的周期基本上全都是SDO帧，偶尔会有同步帧。在极个别的特殊场景下可能会出现全部依靠SDO帧操作的情况。  
每条机械臂的电机都从1一直到6。  
为了确保总线不竞争，以及避免单一电机出问题，威胁整条机械臂的安全。发送必须是单线程的，不能并行发送。

## 架构思路
一共有三个主要的线程：  
#### 接收线程：
接收到来自串口的CAN帧消息以后，根据ID和头信息分析消息类型。  
如果是SDO，则通过一些机制通知发送线程继续发送SDO帧，这个过程可以引入枚举变量作为状态机，判断是否发送以及发送是否成功。  
如果是PDO，根据ID和映射表这种数据结构进行查表。
根据查表结果写入到全局变量的相应数据结构中，提升实时性，空间换时间。
主要写入的内容是诸如“实际电流”“实际速度”“实际位置”“实际状态”这些的十六进制数据

写入完毕后，调用刷新函数进行刷新，把这些十六进制刷新为编码器的值（或者直接到可以用的值），再将编码器的值刷新为可供规划线程读取的值（如角度，速度，电流毫安值等）
####  发送线程：
读取规划线程或者其余线程留下的SDO队列，首先进行SDO的收发，发送出去SDO后，根据接收线程反馈的状态决定是否发送，直到队列发送完毕。
之后根据公共数据结构中规划线程写入的值（已刷新），来读取其中的十六进制数据项目，进而送入发送队列。
然后逐步发送队列中的数据帧。
为了提高性能，生成数据时应该批量生成，批量写入，然后批量发送。

#### 规划线程：
从公共数据结构中读取所需要的数据，进行相应计算和规划。
然后把规划结果写入到诸如“目标电流”“目标位置”“目标速度”“目标状态”这样的公共数据结构中
然后调用刷新方法，将其刷新成十六进制数据。
有时候也负责从外界（诸如外部接口或者高级运动学等功能）接收指令，来进行调整。



#### 公共数据结构（全局数据结构）：
##### 电机类
为了方便数据进行读写，每个电机都保存了一个电机类，所有的电机类的配置都相同（也可以略有不同）
根据读写到的数据写入到全局变量实例化的电机类中，可以节约时间提高实时性。
电机类因为需要频繁读写，所以需要格外注重读写优化以及多线程问题。

##### PDO查找表：
查找表是一种类似于配置文件的数据结构，在编译期通过编译宏和硬编码生成大部分，然后初始化的过程中动态的生成剩下的部分，之后查找表保持静态，只进行读取，不再修改。
在写入和读取的时候，会根据查询表来决定需要读写数据帧的哪些部分，这些部分应该如何分割。  
然后查表，根据相应的映射关系，将电机类的数据结构和查找表进行匹配。这种设计方式的主要目的还是空间换时间，增加通用操作系统的实时性的可靠性。

##### SDO状态机：
SDO每发出去一个请求帧，都会有一个对应的响应帧返回。必须收发线程配合，SDO状态机是在这两个线程之间共享信息的数据结构。需要进行合理的设计，来尽可能降低进程调度和切换的开销，增加SDO发送的性能。
#### 全局队列
全局队列使用boost库的有锁和无锁队列实现
##### 发送队列：
无锁队列，由发送线程单生产单消费，主要保存CAN帧。

##### 接收队列：

无锁队列，接收到的数据会首先从缓冲区转移到这个队列，等待接收线程处理。

##### 规划队列（发送）：
有锁队列，规划线程有时候需要进行模式切换，会将相关的SDO帧在规划线程中编写好并且写入规划队列中，发送线程在每个周期会优先从这里读取SDO帧然后写入到发送队列中。如果有锁则跳过这个写入部分。



## 文件列表

### 老项目文件：
CAN_frame.hpp.txt   CAN帧定义及其相关的一些函数  
CircularBuffer.hpp.txt   自己实现的环形缓冲区，用于收发消息，仅供参考，新项目中计划使用boost的无锁队列代替其功能  
motor_control.hpp.txt  基于SDO的实现的一些基本功能的控制，因为性能较差，不再使用，新版本决定重新实现SDO，再基于新的SDO重写  
read_frame.hpp.txt   基于boost的事件驱动实现的读取，当有CAN帧到达时进行处理，然后分配到指定机械臂的缓冲区，用于实现SDO的读写（这个机制有待提升）  
send_frame.hpp.txt   将CAN帧发送到串口的功能，相对较简单  
can_to_arm.cpp.txt 主函数所在的文件，基于编译宏实现了不同的功能，包括使用多线程驱动机械臂，架构过于冗余  

### 新项目文件：
CAN_frame.hpp  从老项目继承    
CLASS_Motor.hpp 电机类 用于在新架构中作为核心操作的数据结构  
Data_processing.hpp 数据处理的一些函数
PDO_config.hpp 存放各种映射表的所在地
CAN_processing.hpp CAN帧解析和电机状态更新，对接收线程帮助比较大
SDO_State_Machine.hpp SDO状态机，控制SDO的收发  
test_CLASS_Motor.hpp 针对CLASS_Motor.hpp的测试函数所在的文件
test_PDO_config.hpp 针对PDO_config.hpp的PDO配置表的测试函数所在的文件
test_PDO_processing.hpp 针对CAN_processing.hpp中对PDO帧解析的测试函数所在的文件
test_SDO_State_Machine.hpp 针对SDO_State_Machine.hpp的SDO状态机的测试函数所在的文件
CAN_Queue.hpp 各种公共的队列，收发队列等

main.cpp 暂时无功能，主要用来进行测试

### 测试用函数:
都包含在test文件夹内，命名方式为对应文件前面加一个test。每个测试文件测试的内容都对应了一个单个文件内的功能。

## 当前的TODO LIST
0. 全局队列和响应的辅助队列，辅助函数
1. 完成对发送线程的编写和测试
   1.1 从规划线程的规划队列取出SDO帧，写入发送队列，并且通过一个向量变量来标记本轮的SDO帧的数量
   1.2 从发送队列读取SDO（根据SDO帧的数量）
   1.3 将SDO发送，并且根据状态机的模式逐个完成发送，直到SDO帧清空
   1.4 根据PDO配置表生成CAN帧并且写入无锁队列

2. 完成对接收线程的编写和测试
3. 完成对规划线程的编写和测试